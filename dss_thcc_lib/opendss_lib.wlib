<widget_library>
    <version>1.1</version>
    <library_settings>
        <name><![CDATA[OpenDSS]]></name>
        <description><![CDATA[To be used with the OpenDSS Schematic Editor library.]]></description>
    </library_settings>
    <panel_settings>
         <model_locked>False</model_locked>
         <canvas_bg_color>#ffffff</canvas_bg_color>
    </panel_settings>
    <components>
        <component_data>
                <id>ca21a8480b6211ec8aaa7085c234cd76</id>
                <name><![CDATA[Co-simulation]]></name>
                <type>Group</type>
                <description><![CDATA[]]></description>
                <components_ids><![CDATA[['bcb8800d162911ec80b06245b4e7a4ef', 'edc0f5371af311ec938f6245b4e7a4ef', '9b765cb61af411eca8f46245b4e7a4ef', '1c25b3bd1af711ecb6ff6245b4e7a4ef', '9f26cac81af911eca1846245b4e7a4ef', 'd8dfdccc1af911eca5026245b4e7a4ef', '5242888451e611ec9ebbb42e99eebc19']]]></components_ids>
                <canvas_bg_color>#ffffff</canvas_bg_color>
                <initialization_code><![CDATA[# NOTE: Variables and functions defined here will be available for use in 
# all Macro, Expression and handlers codes of components owned by this widget.
# This code is always executed prior simulation start. In case this is a 
# Library widget, this code is also executed on drag and drop, Panel load 
# and widget paste.
#
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

import sys, os


solve_counter = 0
cosim_component_name = ""
added_sources = {}
text_command = ""
free_to_solve = True
previous_total_time = 0
use_other_model = False
other_model_path = ""

dss_model_path = hil.get_ns_var("dsscosim-dss_model_path")
printf("The interface will load the following OpenDSS model:")
printf(dss_model_path)

import opendssdirect as dss


def dss_initialized():
    try:
        dss.Circuit.Name()
        return True
    except Exception as e:
        return False

def get_dss():
    global dss
    return dss
            
def add_current_sources_dss():
    
    global dss
    global cosim_component_name
    global added_sources
    import ast
    
    try:
        isource_buses = ast.literal_eval(hil.get_ns_var("dsscosim-saved_selected_interface_points"))
    except:
        isource_buses = [hil.get_ns_var("dsscosim-saved_selected_interface_points")]
    position_dict = ast.literal_eval(hil.get_ns_var("dsscosim-saved_position_dict"))
    
    all_bus_names = dss.Circuit.AllBusNames()

    added_sources = {}
    for bus in isource_buses:
        if not bus in all_bus_names:
            printf(f"Interface point {bus} was not found in the selected OpenDSS model.")
            return None
        # Add sources per phase.
        for phase_id in position_dict.keys():
            phase = phase_id.split(f'{bus}-')
            if len(phase) == 2: # Incorrect buses will return length 1
                phase = phase[1]
                dss.utils.run_command(f"new Isource.{bus}_interface_{phase} Bus1={bus}.{phase} phases=1 amps=0")
                dss.utils.run_command(f"new Load.{bus}_interface_{phase} Bus1={bus}.{phase} phases=1 kw=0.1")
                added_sources.update({f"{bus}_interface_{phase}": {"phase": phase, "bus": bus}})
                hil.model_write(f'{cosim_component_name}.Vph {bus}-{phase}', 0)
                hil.model_write(f'{cosim_component_name}.Vmag {bus}-{phase}', 0)
    return added_sources
        
def update_isource_values_dss():
    global dss
    global cosim_component_name
    global added_sources
    
    all_source_names = dss.Isource.AllNames()
    updated_values = []
    
    dss.Isource.First()
    for source in dss.Isource.AllNames():
        for isource, phase_dict in added_sources.items():
            if isource == source:
                bus = phase_dict.get("bus")
                phase = phase_dict.get("phase")
                
                # Get current value from the HIL simulation
                i_mag = hil.model_read(f'{cosim_component_name}.Imag {bus}-{phase}') # Magnitude
                i_ph = hil.model_read(f'{cosim_component_name}.Iph {bus}-{phase}') # Angle
                updated_values.append(str(i_mag))
                dss.Isource.Amps(i_mag)
                dss.Isource.AngleDeg(i_ph)
        dss.Isource.Next()
    
    return updated_values
        
def update_vsource_values_dss(disable=False):
    global dss
    global cosim_component_name
    global added_sources
    
    if disable:
        for isource, phase_dict in added_sources.items():
            bus = phase_dict.get("bus")
            phase = phase_dict.get("phase")
            vmag = 0
            vph = 0
            hil.model_write(f'{cosim_component_name}.Vph {bus}-{phase}', vph)
            hil.model_write(f'{cosim_component_name}.Vmag {bus}-{phase}', vmag)
    else:
        try:
            dss.Solution.Solve()
            updated_values = []
            for isource, phase_dict in added_sources.items():
                bus = phase_dict.get("bus")
                phase = phase_dict.get("phase")
                dss.Circuit.SetActiveElement(isource)
                vmagangle = dss.CktElement.VoltagesMagAng()
                vmag = vmagangle[0]
                vph = vmagangle[1]
                updated_values.append(str)
                hil.model_write(f'{cosim_component_name}.Vph {bus}-{phase}', vph)
                hil.model_write(f'{cosim_component_name}.Vmag {bus}-{phase}', vmag)
                
            return updated_values
        except Exception as e:
            if str(e) == "(99, '')": # Workaround for unknown error
                dss.Text.Command("visualize currents")
                
                
def initialize_cosim_model(use_other_model, other_model_path):
    
    global dss
    global dss_model_path
    global cosim_component_name
    
    if use_other_model:
        model_path = other_model_path
    else:
        model_path = dss_model_path

    # OpenDSS Cosimulation
    cosim_component_name = hil.get_ns_var("dsscosim-component_name")
    
    dss.Basic.ClearAll()
    dss.Basic.NewCircuit('init')
    
    dss.Basic.AllowEditor(0)
    dss.utils.run_command(f'Compile "{model_path}"')

    try:
        dss.Circuit.Name()
    except Exception as e:
        print(f"Unable to load the OpenDSS model from the specified path: {model_path}\n{e}")
    
    return cosim_component_name
    
dss.Basic.ClearAll()]]></initialization_code>
                <library_widget_help><![CDATA[None]]></library_widget_help>
                <widget_settings>
                    <x>184</x>
                    <y>88</y>
                    <width>704</width>
                    <height>232</height>
                    <appearance><![CDATA[Flat]]></appearance>
                    <collapsed>False</collapsed>
                    <hierarchy_position>1</hierarchy_position>
                    <label><![CDATA[OpenDSS Co-simulation]]></label>
                    <use_label>True</use_label>
                </widget_settings>
                
                <linked_model_components_settings>
                    </linked_model_components_settings>
            </component_data>
        <component_data>
                <id>bcb8800d162911ec80b06245b4e7a4ef</id>
                <name><![CDATA[Snapshot solve counter]]></name>
                <type>TextDisplay</type>
                <description><![CDATA[]]></description>
                <code><![CDATA[# HIL API is imported as 'hil'
# NOTE: Only read functions are available from the HIL API

# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# specify Text Display options ('text' part is mandatory)

global solve_counter

textDisplayData = {

    # label text
    "text": str(solve_counter),

    # text color: 'red', 'green', 'blue', 'orange', 'black'
    "text_color": 'black',
}

# mandatory variable used for storing value that will be displayed
displayValue = textDisplayData
]]></code>
                <updateRate>250</updateRate>
                <widget_settings>
                    <x>512</x>
                    <y>72</y>
                    <width>154</width>
                    <height>50</height>
                    <appearance><![CDATA[Flat]]></appearance>
                    <hierarchy_position><![CDATA[2]]></hierarchy_position>
                    <is_background><![CDATA[False]]></is_background>
                    <label><![CDATA[]]></label>
                    <use_label>False</use_label>
                </widget_settings>
            </component_data>
        <component_data>
                <id>edc0f5371af311ec938f6245b4e7a4ef</id>
                <name><![CDATA[Initialize OpenDSS model]]></name>
                <type>Macro</type>
                <description><![CDATA[]]></description>
                <on_click_code active="True"><![CDATA[# NOTE: The code specified in this handler will be executed on button click.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

global use_other_model
global other_model_path

dss = get_dss()

if free_to_solve and dss_initialized():
    update_vsource_values_dss(disable=True)
else:
    cosim_component_name = initialize_cosim_model(use_other_model, other_model_path)
    add_current_sources_dss()
        
                

]]></on_click_code>
                <on_start_code active="True"><![CDATA[# NOTE: The code specified in this handler will be executed on simulation start.
# NOTE: Variables specified here will be available in other handlers.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.]]></on_start_code>
                <on_timer_code active="True"><![CDATA[# NOTE: The code specified in this handler will be executed on timer event.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

dss = get_dss()
global solve_counter
global text_command

if dss_initialized():
    # Execute command in the queue
    if text_command:
        dss.Basic.AllowEditor(1)
        dss.Text.Command(f"{text_command}")
        text_command = None    
        dss.Basic.AllowEditor(0)
        free_to_solve = False
    else:
        free_to_solve = True
            
    if free_to_solve:
        upd_isources = update_isource_values_dss()
        if upd_isources:
            v_string = update_vsource_values_dss()
            solve_counter += 1
    ]]></on_timer_code>
                <run_each>1000</run_each>
                <on_stop_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed after simulation is stopped.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

]]></on_stop_code>
                <widget_settings>
                    <x>16</x>
                    <y>64</y>
                    <width>200</width>
                    <height>40</height>
                    <appearance><![CDATA[Flat]]></appearance>
                    <hierarchy_position><![CDATA[2]]></hierarchy_position>
                    <is_background><![CDATA[False]]></is_background>
                    <label><![CDATA[]]></label>
                    <use_label>False</use_label>
                </widget_settings>
            </component_data>
        <component_data>
                <id>9b765cb61af411eca8f46245b4e7a4ef</id>
                <name><![CDATA[DSS model initialized]]></name>
                <type>LedDisplay</type>
                <description><![CDATA[]]></description>
                <data_type>Expression</data_type>
                <signal_name><![CDATA[]]></signal_name>
                <hil_device>0</hil_device>
                <led_color>Green</led_color>
                <code><![CDATA[# HIL API is imported as 'hil'
# NOTE: Only read functions are available from the HIL API

# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# mandatory variable used for storing LED indicator state
# True -> On, False -> Off

dss = get_dss()
if dss_initialized():
    displayValue = True
else:
    displayValue = False
]]></code>
                <updateRate>250</updateRate>
                <widget_settings>
                    <x>432</x>
                    <y>72</y>
                    <width>48</width>
                    <height>32</height>
                    <appearance><![CDATA[Flat]]></appearance>
                    <hierarchy_position><![CDATA[2]]></hierarchy_position>
                    <is_background><![CDATA[False]]></is_background>
                    <label><![CDATA[]]></label>
                    <use_label>True</use_label>
                </widget_settings>
            </component_data>
        <component_data>
                <id>1c25b3bd1af711ecb6ff6245b4e7a4ef</id>
                <name><![CDATA[Loaded DSS circuit name]]></name>
                <type>TextDisplay</type>
                <description><![CDATA[]]></description>
                <code><![CDATA[# HIL API is imported as 'hil'
# NOTE: Only read functions are available from the HIL API

# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# specify Text Display options ('text' part is mandatory)

dss = get_dss()
if dss_initialized():
    dss_circuit_name = dss.Circuit.Name()
else:
    dss_circuit_name = "None"    
    
textDisplayData = {

    # label text
    "text": dss_circuit_name,

    # text color: 'red', 'green', 'blue', 'orange', 'black'
    "text_color": 'black',
}

# mandatory variable used for storing value that will be displayed
displayValue = textDisplayData
]]></code>
                <updateRate>250</updateRate>
                <widget_settings>
                    <x>256</x>
                    <y>72</y>
                    <width>200</width>
                    <height>50</height>
                    <appearance><![CDATA[Flat]]></appearance>
                    <hierarchy_position><![CDATA[2]]></hierarchy_position>
                    <is_background><![CDATA[False]]></is_background>
                    <label><![CDATA[]]></label>
                    <use_label>False</use_label>
                </widget_settings>
            </component_data>
        <component_data>
                <id>9f26cac81af911eca1846245b4e7a4ef</id>
                <name><![CDATA[Path]]></name>
                <type>TextBoxMacro</type>
                <description><![CDATA[]]></description>
                <on_use_code active="True"><![CDATA[# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.# NOTE: entered value is available through variable 'inputValue'

global other_model_path

other_model_path = inputValue

]]></on_use_code>
                <on_start_code active="True"><![CDATA[# NOTE: The code specified in this handler will be executed on simulation start.
# NOTE: Variables specified here will be available in other handlers.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it, widget value won't be changed.

global other_model_path

other_model_path = inputValue
]]></on_start_code>
                <on_stop_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed after simulation is stopped.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it, widget value won't be changed.
widgetValue = None
]]></on_stop_code>
                <on_timer_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed periodically each 1000ms.
# HIL API is imported as 'hil'
# NOTE: Only read functions are available from the HIL API
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it, widget value won't be changed.
widgetValue = None
]]></on_timer_code>
                <on_start_code_source><![CDATA[Custom code]]></on_start_code_source>
                <inputValue><![CDATA[None]]></inputValue>
                <inputValueType>string</inputValueType>
                <unit><![CDATA[]]></unit>
                <widget_settings>
                    <x>1432</x>
                    <y>16</y>
                    <width>456</width>
                    <height>32</height>
                    <inputWidgetWidth>400</inputWidgetWidth>
                    <appearance><![CDATA[Flat]]></appearance>
                    <hierarchy_position>2</hierarchy_position>
                    <label><![CDATA[]]></label>
                    <use_label>False</use_label>
                </widget_settings>
            </component_data>
        <component_data>
                <id>d8dfdccc1af911eca5026245b4e7a4ef</id>
                <name><![CDATA[Use other compatible DSS model]]></name>
                <type>CheckBoxMacro</type>
                <description><![CDATA[]]></description>
                <on_use_code active="True"><![CDATA[# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.
# NOTE: entered value is available through variable 'inputValue'

path_widget_handle = panel.get_widget_by_fqn("Co-simulation.Path")
global use_other_model

if inputValue:
    # do something when checkbox is checked
    use_other_model = True
    panel.set_property_value(path_widget_handle, "position", [224, 16])
else:
    # do something when checkbox is unchecked
    use_other_model = False
    panel.set_property_value(path_widget_handle, "position", [800, 16]) # Hide

]]></on_use_code>
                <on_start_code active="True"><![CDATA[# NOTE: The code specified in this handler will be executed on simulation start.
# NOTE: Variables specified here will be available in other handlers.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it, widget value won't be changed.
    
path_widget_handle = panel.get_widget_by_fqn("Co-simulation.Path")
global use_other_model

if inputValue:
    # do something when checkbox is checked
    use_other_model = True
    panel.set_property_value(path_widget_handle, "position", [224, 16])
else:
    # do something when checkbox is unchecked
    use_other_model = False
    panel.set_property_value(path_widget_handle, "position", [800, 16]) # Hide]]></on_start_code>
                <on_stop_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed after simulation is stopped.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it, widget value won't be changed.
widgetValue = None
]]></on_stop_code>
                <on_timer_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed periodically each 1000ms.
# HIL API is imported as 'hil'
# NOTE: Only read functions are available from the HIL API
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it, widget value won't be changed.
widgetValue = None
]]></on_timer_code>
                <on_start_code_source><![CDATA[Custom code]]></on_start_code_source>
                <inputValue><![CDATA[False]]></inputValue>
                <widget_settings>
                    <x>24</x>
                    <y>16</y>
                    <width>184</width>
                    <height>32</height>
                    <appearance><![CDATA[Flat]]></appearance>
                    <hierarchy_position><![CDATA[2]]></hierarchy_position>
                    <is_background><![CDATA[False]]></is_background>
                    <label><![CDATA[]]></label>
                    <use_label>False</use_label>
                </widget_settings>
            </component_data>
        <component_data>
                <id>5242888451e611ec9ebbb42e99eebc19</id>
                <name><![CDATA[Text command]]></name>
                <type>TextBoxMacro</type>
                <description><![CDATA[]]></description>
                <on_use_code active="True"><![CDATA[# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.# NOTE: entered value is available through variable 'inputValue'

if text_command and f"ERROR: " in text_command:
    print(f"last error: {text_command}")
text_command = inputValue]]></on_use_code>
                <on_start_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed on simulation start.
# NOTE: Variables specified here will be available in other handlers.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it, widget value won't be changed.
widgetValue = None

global text_command

text_command = inputValue
]]></on_start_code>
                <on_stop_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed after simulation is stopped.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it, widget value won't be changed.
widgetValue = None
]]></on_stop_code>
                <on_timer_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed periodically each 1000ms.
# HIL API is imported as 'hil'
# NOTE: Only read functions are available from the HIL API
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it, widget value won't be changed.
widgetValue = None
]]></on_timer_code>
                <on_start_code_source><![CDATA[Custom code]]></on_start_code_source>
                <inputValue><![CDATA[None]]></inputValue>
                <inputValueType>string</inputValueType>
                <unit><![CDATA[]]></unit>
                <widget_settings>
                    <x>120</x>
                    <y>128</y>
                    <width>432</width>
                    <height>32</height>
                    <inputWidgetWidth>345</inputWidgetWidth>
                    <appearance><![CDATA[Flat]]></appearance>
                    <hierarchy_position>2</hierarchy_position>
                    <label><![CDATA[]]></label>
                    <use_label>False</use_label>
                </widget_settings>
            </component_data>
        </components>
</widget_library>